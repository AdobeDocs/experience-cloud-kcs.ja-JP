---
title: キャッシュについて
description: 説明
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: 2/7/2022 5:13:07 PM
article-published-by: Roxann McGlumphy
article-published-date: 2/7/2022 5:13:28 PM
version-number: 3
article-number: KA-17912
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ee0f4935-3988-ec11-93b0-0022480837ff
exl-id: a5da3fc9-c0a0-4d5a-8369-a96dad9e2b49
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1517'
ht-degree: 1%

---

# キャッシュについて

## 説明

このドキュメントでは、Dispatcher のキャッシュの発生方法と設定方法について説明します<br><br> <br><br>[目次](https://experienceleague.adobe.com/docs/experience-cloud-kcs/kbarticles/KA-17490.html?lang=ja)

## 解像度


<b>ディレクトリのキャッシュ</b>

ベースラインインストールでは、次のデフォルトのキャッシュディレクトリを使用します

- 作成者

   - /mnt/var/www/author
- 発行者

   - /mnt/var/www/html


各リクエストが Dispatcher を走査する際、リクエストは設定されたルールに従い、対象となる項目への応答に応じてローカルにキャッシュされたバージョンを維持します

<b>注釈:</b>

Apache が DocumentRoot でファイルを検索すると、どのAEMインスタンスから来たのかがわからなくなるので、オーサーワークロードとは別の公開済みワークロードを意図的に保持しています。 したがって、オーサーファームでキャッシュが無効になっている場合でも、オーサーの DocumentRoot がパブリッシャーと同じ場合は、キャッシュのファイルが存在するときにそのキャッシュから提供されます。 つまり、公開されたキャッシュからオーサーファイルを提供し、訪問者にとって非常にひどいミックスマッチエクスペリエンスを提供します。 公開されているコンテンツごとに別々の DocumentRoot ディレクトリを保持するのも、非常に悪い考えです。 clientlibs などのサイト間で異なることのない、再キャッシュされた複数の項目を作成し、設定した各 DocumentRoot に対してレプリケーションフラッシュエージェントを設定する必要があります。 ページをアクティベートするたびに、ヘッドの上のフラッシュ量を増やします。 ファイルの名前空間と完全にキャッシュされたパスに依存し、公開済みサイトで複数の DocumentRoot が使用されるのを防ぎます。



<b>設定ファイル</b>

Dispatcher は、任意のファームファイルの/cache { セクションで、何がキャッシュ可能と見なされるかを制御します。 
AMS ベースライン設定ファームには、次のようなインクルードが含まれます。


```
/cache { 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    }
```


キャッシュする対象またはキャッシュしない対象のルールを作成する場合は、ドキュメントを参照してください [ここ](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)



<b>作成者のキャッシュ</b>

ユーザーがオーサーコンテンツをキャッシュしない実装は、多数あります。 
作成者に対するパフォーマンスと応答性の大幅なアップグレードが見つかりません。

オーサーファームを正しくキャッシュするように設定する際に実行する方法について説明します。

オーサーファームファイルのベースオーサー/cache { セクションを次に示します。


```
/cache { 
    /docroot "/mnt/var/www/author" 
    /statfileslevel "2" 
    /allowAuthorized "1" 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    } 
    /invalidate { 
        /0000 { 
            /glob "*" 
            /type "allow" 
        } 
    } 
    /allowedClients { 
        /0000 { 
            /glob "*.*.*.*" 
            /type "deny" 
        } 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_invalidate_allowed.any" 
    } 
}
```


ここで注意すべき重要な点は、 <b>/docroot</b> は、オーサーのキャッシュディレクトリに設定されます。

<b>注釈:</b>

作成者の.vhost ファイル内の DocumentRoot がファームの/docroot パラメーターと一致していることを確認します。

キャッシュルール include ステートメントには、ファイルが含まれます <b>/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any</b> これには次のルールが含まれます。


```
/0000 { 
 /glob "*" 
 /type "deny" 
} 
/0001 { 
 /glob "/libs/*" 
 /type "allow" 
} 
/0002 { 
 /glob "/libs/*.html" 
 /type "deny" 
} 
/0003 { 
 /glob "/libs/granite/csrf/token.json" 
 /type "deny" 
} 
/0004 { 
 /glob "/apps/*" 
 /type "allow" 
} 
/0005 { 
 /glob "/apps/*.html" 
 /type "deny" 
} 
/0006 { 
 /glob "/libs/cq/core/content/welcome.*" 
 /type "deny" 
}
```


オーサーシナリオでは、コンテンツは常に時間と目的に変更されます。 頻繁に変更されない項目のみをキャッシュします。
/libs をキャッシュするルールがあります。これらはAEMのベースラインインストールの一部であり、Service Pack、Cumulative Fix Pack、Upgrade、または Hotfix をインストールするまで変更されます。 したがって、これらの要素をキャッシュすることは非常に理にかなっており、サイトを使用するエンドユーザーのオーサーエクスペリエンスの大きなメリットをもたらします。

<b>注釈:</b>

これらのルールは、 <b>/apps</b> カスタムアプリケーションコードが存在する場所です。 このインスタンスでコードを開発している場合、ファイルを保存する際に非常に混乱が生じ、キャッシュされたコピーが提供されるので、UI に反映されるかどうかがわかりません。 ここでの目的は、コードをAEMにデプロイする場合も頻繁ではなく、デプロイメント手順の一部としてオーサーキャッシュをクリアする必要があるということです。 このメリットも大きく、エンドユーザーに対してキャッシュ可能なコードの実行を高速化できる点です。



<b>ServeOnStale （SOS で提供される古い/SOS）</b>

これは、Dispatcher の機能の 1 つの宝石です。 パブリッシャーが読み込み中であるか、応答しなくなった場合、通常は 502 または 503 http 応答コードがスローされます。 これが発生し、この機能が有効になっている場合、新しいコピーでなくても、キャッシュ内のコンテンツがすべてベストエフォートとして提供されるよう Dispatcher に指示されます。 機能を提供しないエラーメッセージを表示するのではなく、表示している場合は何かを提供する方が良いです。

<b>注釈:</b>

パブリッシャーレンダラーがソケットタイムアウトまたは 500 エラーメッセージを持っている場合、この機能はトリガーしません。 AEMに単に到達できない場合、この機能は何もしません

この設定は任意のファームで設定できますが、パブリッシュファームファイルに適用すると効果的です。 次に、ファームファイルで有効になっている機能の構文例を示します。


```
/cache { 
    /serveStaleOnError "1"
```




<b>クエリパラメーター/引数を含むページのキャッシュ</b>

<b>注釈:</b>

Dispatcher モジュールの通常の動作の 1 つは、要求の URI にクエリパラメーターが含まれている場合です ( 通常、 /content/page.htmlのように表示されます )<b>?myquery=value</b>) ファイルのキャッシュをスキップし、AEMインスタンスに直接移動します。 このリクエストは動的ページであると考えられており、キャッシュしないでください。 これは、キャッシュの効率に影響を与える可能性があります。

ページの動作に役立つが、異なる html をレンダリングしないアドレス行にGET引数/クエリパラメーターを持つAEM内のページがある場合、この設定要素の適切な候補です。どの引数を無視し、引き続きページをキャッシュするかを Dispatcher に指定できます。
例えば、誰かがソーシャルメディアのディープリンク参照メカニズムを構築し、URI 内の引数参照を使用して、その人物の出身地を把握しています。

<b>使用例：</b>

[https://www.retail.com/home.html?reference=android](https://www.retail.com/home.html?reference=android)

[https://www.retail.com/home.html?reference=facebook](https://www.retail.com/home.html?reference=facebook)

ページは 100%キャッシュ可能ですが、引数が存在するのでキャッシュされません。 
これを回避するには、次のセクションをファーム設定ファイルに追加します。


```
/cache { 
    /ignoreUrlParams { 
        /0001 { /glob "*" /type "deny" } 
        /0002 { /glob "reference" /type "allow" } 
    }
```


現在は、Dispatcher がリクエストを確認すると、リクエストのクエリパラメーターが？reference のままで、ページをキャッシュしているという事実が無視されます



<b>応答ヘッダーのキャッシュ</b>

Dispatcherが.html ページと clientlibs をキャッシュするのは明白ですが、同じ名前でファイル拡張子が.hのファイルで、コンテンツの横に特定の応答ヘッダーをキャッシュできることはご存知でした。 これにより、次の応答がコンテンツに対する応答だけでなく、キャッシュからの応答ヘッダーに対しておこなわれます。

AEMは単なる UTF-8 エンコーディング以上を処理できます

アイテムには、キャッシュ TTL のエンコーディングの詳細や最終変更日のタイムスタンプを制御するのに役立つ特別なヘッダーが含まれている場合があります。

キャッシュ時のこれらの値はデフォルトで削除され、apache httpd Web サーバーは、通常のファイル処理メソッドでアセットを処理する独自のジョブを実行します。通常は、ファイル拡張子に基づく MIME タイプ推測に制限されます。

Dispatcher がアセットと目的のヘッダーをキャッシュしている場合は、適切なエクスペリエンスを公開し、すべての詳細がクライアントブラウザーに表示されるようにします。

次に、キャッシュするヘッダーが指定されたファームの例を示します。


```
/cache { 
 /headers { 
  "Cache-Control" 
  "Content-Disposition" 
  "Content-Type" 
  "Expires" 
  "Last-Modified" 
  "X-Content-Type-Options" 
 } 
}
```


この例では、CDN が探すヘッダーを提供するようにAEMを設定し、そのヘッダーがキャッシュを無効にするタイミングを知っています。 つまり、AEMでは、ヘッダーに基づいて無効化するファイルを適切に指定できるようになりました。

<b>注釈:</b>

正規表現や glob 照合は使用できないことに注意してください。 キャッシュするヘッダーのリテラルリストです。 キャッシュするリテラルヘッダーのリストのみを配置します。



<b>猶予期間の自動無効化</b>

多くのページアクティベーションをおこなう作成者のアクティビティが多いAEMシステムでは、無効化が繰り返し発生する競合状態になる場合があります。 大量に繰り返されるフラッシュリクエストは不要で、猶予期間がクリアされるまでフラッシュを繰り返さないよう、ある程度の許容値を構築できます。

<b>この仕組みの例：</b>

/content/exampleco/en/を無効にする 5 つのリクエストがある場合、すべては 3 秒以内に発生します。

この機能をオフにすると、キャッシュディレクトリ/content/exampleco/en/が 5 回無効化されます。

この機能をオンにして 5 秒に設定すると、キャッシュディレクトリ/content/exampleco/en/が無効になります。<b>1 回</b>

次に、この機能を 5 秒の猶予期間用に設定する構文の例を示します。


```
/cache { 
    /gracePeriod "5"
```




<b>TTL ベースの無効化</b>

Dispatcher モジュールの新しい機能は、次のとおりです。 <b>有効期間 (TTL)</b> キャッシュされた項目の無効化オプションに基づいています。 アイテムがキャッシュされると、キャッシュ制御ヘッダーが存在するかどうかを調べ、同じ名前と <b>.ttl</b> 拡張子。

ファーム設定ファイルで設定する機能の例を次に示します。


```
/cache { 
    /enableTTL "1"
```


<b>注釈:</b>

AEMが TTL ヘッダーを送信するように設定して、Dispatcher がヘッダーを処理できるようにする必要があります。 この機能を切り替えると、AEMがキャッシュ制御ヘッダーを送信したファイルを削除するタイミングを Dispatcher が把握できるようになります。 AEMが TTL ヘッダーの送信を開始しない場合、Dispatcher はここで特別な処理を実行しません。



<b>キャッシュフィルタールール</b>

パブリッシャー上でキャッシュする要素のベースライン設定の例を次に示します。


```
/cache{ 
    /0000 { 
        /glob "*" 
        /type "allow" 
    } 
    /0001 { 
        /glob "/libs/granite/csrf/token.json" 
        /type "deny" 
    }
```


公開したサイトをできるだけ貪欲にし、すべてをキャッシュしたいと考えています。

キャッシュ時にエクスペリエンスを壊す要素がある場合は、ルールを追加して、その項目をキャッシュするオプションを削除できます。 上の例で示すように、csrf トークンはキャッシュされず、除外されています。 これらのルールの作成に関する詳細は、こちらを参照してください [ここ](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)
