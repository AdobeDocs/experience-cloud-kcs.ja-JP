---
title: Campaign Classic- [!UICONTROL 増分クエリ] 新しいレコードだけでなく、すべてのレコードを取得します
description: 説明
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS
resolution: Resolution
internal-notes: Ticket = TK197178
bug: true
article-created-by: Marta Zator
article-created-date: 5/10/2022 9:47:14 AM
article-published-by: Marta Zator
article-published-date: 5/10/2022 9:51:21 AM
version-number: 2
article-number: KA-15190
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ad8bd527-46d0-ec11-a7b5-00224809c101
exl-id: f3dee0a7-8047-4949-9162-de95ba07fa7f
source-git-commit: dc1937169029c76dbce1ba513dd6430dffbc86c5
workflow-type: tm+mt
source-wordcount: '516'
ht-degree: 0%

---

# Campaign Classic- [!UICONTROL 増分クエリ] 新しいレコードだけでなく、すべてのレコードを取得します

## 説明

お客様には、正常に機能しない増分クエリがいくつか存在します。 前回の実行以降に新しいレコードのみを取得するのではなく、通常のように、毎回すべてのレコードを取得します [!UICONTROL クエリ] アクティビティ。

## 解決策

犯人は [!UICONTROL Cleanup] ワークフロー。

この [!UICONTROL 増分クエリ] ワークフローは次のように動作します。

1. 以前のイテレーションの結果を含む履歴テーブルを維持します。
1. ターゲットクエリからすべての行を取得します。
1. 履歴テーブルに存在するすべての行を除外
1. 次のイテレーションフィルタリングのために、残りの結果を履歴テーブルに追加します。

したがって、この履歴ワークテーブル名は次のような表記になります。

*wkfhistoworkflowid* activityName_

ワークフロー ID 0 の場合（を満たす顧客の場合） `xtknewid` 負のシーケンスを許可します）。実際には、次のようになります。

*wkfhito （uint） workflowid* activityName_

ワークフローの実行は問題ありませんが、

例えば、増分アクティビティの場合はです `incremental1` のワークフロー ID=-1 がテーブルを作成します `wkfhisto4294967295_incremental1`.

見逃されるのは、 [!UICONTROL Cleanup] ワークフロー。

ここでは、削除されたワークフローのワークテーブルを削除しようとするコードを示します。

ここに専用コードを書くと、すべての wkfhito\* テーブルが一覧表示され、名前から（上記の規則に従って） workflowId が抽出されます。そして、xtkworkflow テーブル内で worklowID が見つかったテーブルを除くすべてのテーブルが削除されます。

ただし、 `uint` パーツ：

そのため、ID が 4294967295 のワークフローを検索しようと試みます。 このワークフローが見つからないので、このテーブルは削除されます。 次回このワークフローを実行すると、 [!UICONTROL 増分クエリ] アクティビティでは、既存の履歴テーブルが見つからず、これが最初の実行と見なされて作成されます。

<b>修正：</b>

この問題の修正は、Adobe Campaign Classic 20.1.1 リリース（ビルド 9122 以降）で利用できます。

<b>お客様が使用できる回避策：</b>

回避策 1：クリーンアップワークフローを停止し、断続的に実行して、修正が行われて使用可能になるまでデータベースと HDD をクリーンアップします。 予定されているアップグレードがない場合は、お勧めしません。

回避策 2：次のとおりとします [!UICONTROL 増分クエリ] アクティビティに影響が及び、 [!UICONTROL 増分クエリ] 履歴テーブルの内容を保持する永続的なスキーマを作成することで実行されます。 次の組み合わせを使用します [!UICONTROL クエリ] および [!UICONTROL データを更新] 動作を模倣するアクティビティ。 これは、増分処理クエリを必要とするすべてのワークフローについて行う必要があります。

回避策 3：次のとおりとします [!UICONTROL 増分クエリ] アクティビティに影響を与え、該当するスキーマに監査フィールド （tsCreated/tsLastModified）を追加することでアクティビティを回避します。 増分処理クエリは、次のような where 句を持つ通常のクエリアクティビティに変換されます。 `tscreated GetDate()`.

回避策 4:

- 新しいシーケンス xtknewworkflowid を作成し、現在の workflowId の範囲から離れたところまで初期化します。
- これを使用するように xtkworkflow スキーマを変更する `pkSequence`
- 影響を受けるすべてのワークフローを複製し、元のワークフローを削除するように、お客様に依頼します。
- アップグレードの準備が整ったら、に戻してこの修正を削除します。 `xtknewId` ワークフローの作成（不要な驚きを回避するため）。
