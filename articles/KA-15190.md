---
title: 「増分処理クエリでは、新しいレコードのみではなく、すべてのレコードが取得されます」
description: 説明
solution: Campaign
product: Campaign
applies-to: "Campaign Classic"
keywords: "KCS"
resolution: Resolution
internal-notes: "Ticket = TK197178"
bug: true
article-created-by: Tanay Sharma .
article-created-date: "9/26/2022 10:11:48 AM"
article-published-by: Tanay Sharma .
article-published-date: "9/26/2022 11:03:23 AM"
version-number: 3
article-number: KA-15190
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e647789f-833d-ed11-9db1-002248086735"
source-git-commit: c07227262cb059b09254e8e1ec01542d4de2a881
workflow-type: tm+mt
source-wordcount: '353'
ht-degree: 0%

---

# 増分処理クエリは、新しいレコードのみではなく、すべてのレコードを取得します

## 説明

<b>環境</b>
Campaign Classic


<b>問題/症状</b>
増分クエリが期待どおりに動作しません。 最後の実行以降に新しいレコードを取得するだけでなく、通常のクエリアクティビティのように、毎回すべてのレコードを取得します。


## 解像度


この問題は、Adobe Campaign Classic 20.1.1 リリース（ビルド 9122 以降）で修正されました。

<b>お客様が使用できる回避策：</b>

<b>回避策 1</b>:クリーンアップワークフローを停止し、断続的に実行して、修正が行われ使用可能になるまでデータベースと HDD をクリーンアップします。 アップグレードを計画していない場合は、お勧めしません。

<b>回避策 2</b>:「増分処理クエリ」アクティビティが影響を受けるとします。 増分処理クエリと同じ処理を行い、履歴テーブルのコンテンツを保持する永続的なスキーマを作成します。 クエリと更新データアクティビティの組み合わせを使用して、動作を模倣できます。 増分処理クエリを必要とするすべてのワークフローに対して、この処理を実行する必要があります。

<b>回避策 3</b>:  「増分処理クエリ」アクティビティが影響を受けるとします。 監査フィールドを追加して対処する `tsCreated/tsLastModified` を問題のスキーマに追加します。 その後、増分処理クエリは、「tscreated GetDate()」のような where 句を含む通常のクエリアクティビティに変換されます。

<b>回避策 4</b>:

1. 新しいシーケンスの作成 `xtknewworkflowid` 現在の workflowId 範囲から遠い範囲に初期化します。
2. を `xtkworkflow` これを使用するスキーマ `pkSequence`.
3. 影響を受けるすべてのワークフローを複製し、元のワークフローを削除するように顧客に依頼します。
4. お客様がアップグレードの準備が整ったら、次の手順に戻して、この修正を削除します。 `xtknewId` （不要な不測の事態を避けるために）ワークフローを作成する場合。

<b>原因</b>
原因はクリーンアップワークフローです。

増分処理クエリワークフローは次のように機能します。

1. 以前の反復の結果を含む履歴テーブルを維持します。
2. ターゲットクエリからすべての行を取得します。
3. 履歴テーブルに存在するすべての行を除外します
4. 残りの結果を次の反復フィルタリングの履歴テーブルに追加します。


したがって、この履歴作業用テーブル名は次のような表記になります。
`wkfhistoworkflowid` `activityName_`

現在は、workflowID 0( `xtknewid` では、負のシーケンスを使用できます )、実際には次のようになります。

`wkfhisto(uint)workflowid``activityName_`

`Although this is okay for workflow execution.`

`So, for example, the incremental activity incremental1 of workflow ID=-1 will create a table wkfhisto4294967295_incremental1`.`

`The thing which is missed is the CleanUp workflow.`

`Here, we have a code that tries to delete worktables of deleted workflows.`

`A dedicated code here lists all the wkfhisto tables, extracts the workflowId from their names (from the above convention), and deletes them all except the ones whose worklowIDs are found in the xtkworkflow table.`

`However, it misses the uint part.`

`So, it tries to look up a workflow with ID 4294967295 instead of casting this back to int. Since this workflow is not found, this table is deleted. Next time, when this workflow runs, the incremental query activity does not find an existing history table and creates it thinking of this as the first run ever.`
