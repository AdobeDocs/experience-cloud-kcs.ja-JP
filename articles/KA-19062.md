---
title: 問題がAEM 6.x で報告された場合の SegmentNotFoundException のデバッグ方法
description: 説明
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Akash Kapoor
article-created-date: 4/3/2022 7:14:43 PM
article-published-by: Akash Kapoor
article-published-date: 4/3/2022 7:14:58 PM
version-number: 4
article-number: KA-19062
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=63dd174c-82b3-ec11-983f-000d3a5d09d6
exl-id: 0580f08b-a72c-45ec-817e-e850d2360e9d
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1214'
ht-degree: 0%

---

# 問題がAEM 6.x で報告された場合の SegmentNotFoundException のデバッグ方法

## 説明


<b>問題がAEM 6.x で報告された場合の SegmentNotFoundException のデバッグ方法</b>

A <b>SegmentNotFoundException</b> エラーログには、明らかに誰かがアクセスを試みたが、セグメントが存在しなくなったことが示されます。 これには、大きく 3 つの根本的な原因があります。セグメントが手動の操作（rm -rf /など）によって削除された、セグメントがリビジョンのガベージコレクションによって削除された、またはコード内のバグが原因でセグメントが見つからない、など。

ログに次のような例外が表示される場合があります。

...

org.apache.jackrabbit.oak.segment.SegmentNotFoundException:org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:602) at org.apache.jackrabbit.oak.602) でセグメント d2c720c4-c146-4ab1-ac37-542aad93c3f が見つかりません org.apache.jackrabbit.oak.segment.SegmentCache.getSegment(SegmentCache.java:95) at org.apache.jackrabbit.oak.segment.file.FileStore.readSegment(FileStore.java:542)) org.apache.jackrabbit.oak.segment.SegmentId.getSegment(SegmentId.java:125) at org.apache.jackrabbit.oak.segment.Record.getSegment(Record.java:70) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRe:424244) org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:391) at org.apache.jackrabbit.oak.segment.CompareCateAtAtAtBaseStateAutorg.apache.jackrabbit.oak.spi.commit.EditorDiff.childNodeChanged(EditorDiff.java:148) at org.apache.jackrabbit.oak.segment.MapRecord$3.childNodeChanged(MapRecord.java:44)2) org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:490) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) at org.apache.jackrabbit.oak.segment.CompareAteAteAtAtAtAeAtBaseBaseAtorg.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52) at org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.updateIndex(AsyncIndexUpdate.java:695) at orgorg.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.runWhenPermitted(AsyncIndexUpdate.java:543) at org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.run(AsyncIndexUpdate.java:402) at org.apache.sling.s.sling.commons.commons.commons.java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolPoolWorker(ThreadPoolPoolPoolTor)) で org.quartz.core.JobRunShell.run(JobRunShell.java:202)に.impl.QuartJobExecutor.joJo.java:1118java.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)

...


## 解像度


以下の A 節と B 節で説明するリポジトリの不整合を解除するために、以下の 2 つの方法を使用できます。

<b>A.セグメントストアの正常な最新のリビジョンに戻します。</b>

まず、簡単な Oak のインストールと oak 関連の操作の実行に必要なすべてを含む実行可能 jar1 である oak run ツールを使用する必要があります。

oak-run のチェック実行モードを使用して、セグメントストアの最新の正常なリビジョンを判断できます。  これを使用して、破損したセグメントストアを最新の適切なリビジョンに手動で戻すことができます。

*注意：このプロセスは、システム内のデータを以前の時点にロールバックします。  システムの変更が失われないようにしたい場合は、代わりに以下のオプション B を試してみてください。*

チェックと復元を実行するには、次の手順に従います。

1. oak コアバージョンに一致する oak-run のバージョンをからダウンロードします。 [https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run](https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run)
2. 破損したセグメントストアを最新の適切な状態に戻すには、CQ の作業ディレクトリ（crx-quickstartfolder を含むディレクトリ）に変更し、内のすべてのファイルをバックアップします。/crx-quickstart/repository/segmentstore/に設定します。
3. 整合性チェックを実行します。 java -Xmx6000m -jar oak-run-\*.jar check —bin=-1 /path/to/crx-quickstart/repository/segmentstore 整合性チェックが見つかるまで、リビジョンを逆に検索します。以下のようなメッセージを探します。main INFO o.a.j.o.p.s.f.t.ConsistencyChecker — 最新の良いリビジョン afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880が見つかりました
4. を編集して、リポジトリをこのリビジョンに戻します。/crx-quickstart/repository/segmentstore/journal.logを参照し、最新の適切なリビジョンを含む行の後のすべての行を削除します。
5. すべてを削除します。/crx-quickstart/repository/segmentstore/\*.bak ファイル
6. 次のコマンドを使用して、孤立したチェックポイントを削除するには、チェックポイントのクリーンアップを実行します。java -Xmx6000m -jar oak-run-\*.jar checkpoints /path/to/crx-quickstart/repository/segmentstore rm-unreferenced
7. 最後に、リポジトリをコンパクトします。java -Xmx6000m -jar oak-run-\*.jar compact /path/to/crx-quickstart/repository/segmentstore/




*check コマンドの実行中に、oak 実行チェックで適切なリビジョンが見つからず、「ConsistencyChecker - No good revision found」が表示される場合があります。*
<b>整合性チェックで「ConsistencyChecker - No good revision found」が発生した場合の破損を修正する方法</b>


<b>B.破損したノードを手動で削除します。</b>

FileDatastore が設定されていないAEM、TarMK 設定およびバイナリで破損が発生する状況では、次の操作を実行できます。

\*注意n:\*以下の手順は、パワーユーザー向けです。  破損したノードを削除する場合は、それらがシステムノード（ /home、/jcr:system など）でないことを確認する必要があります。  また、システムノードの場合は、復元できることを確認する必要があります。  不明な場合は、こちらに記載されている手順について、AEMカスタマーケアチームにお問い合わせください。



1. AEMを停止します。
2. Oak 実行コンソールを使用し、 childCount groovy スクリプトを読み込んで、セグメントストア内の破損したノードを識別します。


oak-run コンソールシェルを読み込みます。

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

シェルで次の 2 つのコマンドを実行してスクリプトを読み込み、実行します。

:load https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy

countNodes(session.workingNode)

これにより、次の出力が破損したノードへのパスを示します。

21:21:42.029 メインエラー o.a.j.o.p.segment.SegmentTracker — セグメントが見つかりません：63ae05a4-b506-445c-baa2-cfa1b13b6e2f. 作成日の差分は 3 ミリ秒です。

警告ノード/content/dam/test.txt/jcr:content/renditions/original/jcr:content を読み取れません

場合によっては、問題がバイナリプロパティに関連しており、 childCount groovy スクリプトが破損したノードを見つけられないことがあります。  この場合、次のコマンドを使用すると、トラバーサル中に発生したすべてのバイナリの最初の 1024 バイトを読み取ることができます（このコマンドは低速になり、上記のコマンドが期待された結果を返さない場合にのみ使用します）。

countNodes(session.workingNode,true)

3. rmNodes.groovy を使用して、最後のコマンドの出力にリストされている、識別された破損したノードをすべて削除します。

次のコマンドを使用して、oak-run コンソールシェルを読み込みます。

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

groovy スクリプトを読み込みます。

:load

https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy

rmNode コマンドを実行して、破損したノードを削除し、 /path/to/corrupt/node を、削除する破損したノードのパスに置き換えます。

rmNode(session, &quot;/path/to/corrupt/node&quot;)

破損したノードのパスは、手順 2 で取得したパスです。次に例を示します。&quot;/content/dam/test.txt/jcr:content/renditions/original/jcr:content/&quot;注意：oak-run.jar バージョン 1.6.13 以降を使用する場合、次のようなエラーが発生した場合は、—read-write JVM パラメータを設定します。

/ rmNode(session,&quot;/path/to/corrupt/node&quot;) ノード/path/to/corrupt/node の削除中 ERROR java.lang.UnsupportedOperationException:   org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171) at org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318) at.apach.apaorg.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581) at.apache.jackrabbit.oak.segment.SegmentNodeStore.merge (SegmentNodeBuilder.java:11)groovysh_evaluate.rmNode (groovysh_evaluate:11) の org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call （不明なソース）で segmentNodeStore.java:333)

4. 手順 2 で見つかったすべてのノードに対して、手順 3 を繰り返します。

この rmNode コマンドは、破損したパスに対して true を返す必要があります。つまり、パスが削除されました。 これらのパスで rmNode コマンドを再実行して、3 つの破損したパスが削除されることを確認します。 次に実行すると、false が返されます。

それでもリポジトリ内に同じパスが存在する場合は、パッチを適用したバージョンの oak-run jar(oak-run-1.2.18-NPR-17596) を使用します。

パッチが適用されたバージョンの Oak run Jar では何をしますか？

このバージョンの jar は、圧縮時に読み取り不能なバイナリをスキップし、0 バイトのバイナリに置き換え、例外と syser へのパスをログに記録します。 このように圧縮されたリポジトリは、oak-run チェック、ノード数スクリプトを渡し、パッチが適用されていない oak-run を使用して再びコンパクト化できるはずです。

5. 以下を使用してチェックポイントをリストし、チェックポイントのクリーンアップを実行します。 複数のチェックポイントがある場合は、次の手順でクリーンアップします。

nohup java -Xmx4096m -jar oak-run-1.2.18.jar checkpoints /app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out &amp;

6. オフライン圧縮を実行します。  オフライン圧縮の実行方法がわからない場合は、 [ここ](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).

7. サーバーを起動し、インデックス作成が完了するまで待ちます。
