---
title: 「Adobe Experience Manager。request.log 分析の例»
description: 説明
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: 「KCS」
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Nobuhiro Hashimoto
article-created-date: "1/24/2023 5:01:17 AM"
article-published-by: Nobuhiro Hashimoto
article-published-date: "1/24/2023 12:09:25 PM"
version-number: 1
article-number: KA-21309
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=a33bb020-a49b-ed11-aad1-6045bd006239"
source-git-commit: afded50ce53d99e1170dc822f940f879cfaea426
workflow-type: tm+mt
source-wordcount: '978'
ht-degree: 1%

---

# Adobe Experience Manager:request.log 分析の例

## 説明 {#description}


AEM request.log には、パフォーマンスの問題を分析する際に役立つ様々な情報（応答時間など）が含まれています。 以下は、Linux コマンド（一部の外部コマンドを含む）を使用した分析例のリストです。

<b>環境</b>
AEM 6.5、Linux(Bash)


## 解決策 {#resolution}

目次：<br><br>
<b>はじめに</b>
  request.log の形式

<b>準備</b>
  手順 1. データクレンジング手順 2. 再起動時間ステップ 3. 1 時間あたりのアクセス数手順 4。 最大同時処理ステップ 5. ログファイルを分割する手順 6. リクエストレコードと応答レコードの結合

<b>分析の例</b>
  例 1. 最も重いアクセス例 2. 欠落した応答にアクセスする例 3. 遅いアクセス例 4 応答時間の時系列データ例 5. 最小、平均（平均）、中央値、最大応答時間例 6. 1 期間あたりのアクセス数例 7. 1 回の期間に対する応答ステータスの数例 8 最も頻繁に使用される URL の例 9. request.log レコードの access.log レコード

<b>まとめ</b>

<br>はじめに<br><br>request.log の形式<br><br>
AEM 6.5 では、デフォルトで、次の形式の request.log が生成されます。 システムの制限により、この記事のコマンドラインは、プレーンテキストではなく画像として表示されます。

request.log の例：
![](assets/e51bfd97-dd9b-ed11-aad1-6045bd006793.png)





この記事では、「 — 」を「リクエストレコード」として含む行を参照します。 「 — 」を含む行は「応答レコード」です。

<b>レコードをリクエスト</b>
  AEMがリクエストを受信すると、リクエストレコードがログに記録されます。 受信の日時、要求 ID、要求メソッドおよび URL が含まれます。

<b>応答レコード</b>
  AEMがリクエストに応答すると、応答レコードがログに記録されます。 応答の日時、リクエスト ID、ステータスコード、Content-Type、応答時間（ミリ秒）が含まれます。

対応するマニュアルも参照してください。https://experienceleague.adobe.com/docs/experience-manager-65/deploying/configuring/monitoring-and-maintaining.html?lang=en#interpreting-the-request-log

<br>準備<br><br>手順 1. データクレンジング<br><br>
request.log の分析を参照する前に、ログレコードを標準化することが重要です。

![](assets/2a1adef4-dd9b-ed11-aad1-6045bd006793.png)





最初の sed コマンドは、応答レコードの Content-Type の余分なスペースを削除し、空白でのフィールドの間違った分離を防ぎます。 ruby コマンドは、日付形式を ISO 8601 に変換します。 また、ルビーコマンドはコロンではなく空白で日付と時刻を区切ります。

<br>手順 2. 再開時間<br><br>
AEMとサービスパックのインストールを再起動すると、request.log のリクエスト ID がリセットされます。 リクエスト ID = 0 のリクエストレコードは、このような操作がある可能性があることを示します。

![](assets/777fcc1e-de9b-ed11-aad1-6045bd006793.png)













上記の例では、リクエスト ID は 13 時に 0 にリセットされていました:08:49と13:26:13.

<br>手順 3. 1 時間あたりのアクセス数<br><br>
1 時間あたりのアクセス数と、request.log の時間範囲をカウントします。

![](assets/712fae49-de9b-ed11-aad1-6045bd006793.png)
<br><br> <br><br> <br><br> <br><br>
<br>手順 4. 同時処理の最大数<br><br>
同時処理の数は、AEMのサーバー負荷を推測するのに役立ちます。

![](assets/7b359b5c-de9b-ed11-aad1-6045bd006793.png)







デフォルトでは、AEMの Jetty の同時接続の最大数は 200 に設定されています。 応答が完了した後にソケットを解放する際に遅延が生じます。 同時処理の数が約 170 を超えると、新しいリクエストを受け入れられなくなります。

<br>手順 5. ログファイルの分割<br><br>
request.log のリクエスト ID は、AEMが再起動したとき、または Service Pack がインストールされたときにリセットされます。 この動作により、request.log にそのような操作が含まれている場合、分析が正しくない可能性があります。 正確な分析を実行し、一度に処理されるファイルサイズを減らすには、リクエスト ID = 0 のリクエストレコードを使用して request.log を分割します。

![](assets/a342906e-de9b-ed11-aad1-6045bd006793.png)













<br>手順 6. リクエストレコードと応答レコードの結合<br><br>
リクエスト ID を使用してリクエストと応答レコードを結合すると、パフォーマンスの問題が開始したタイミングを簡単に見つけることができます。 このマージ済みログファイルを後の例で使用します。

![](assets/e3848b8c-de9b-ed11-aad1-6045bd006793.png)







最後の sed コマンドは、対応する応答レコードを持たないリクエストレコードにダミーの応答を追加します。 また、リクエストレコードを持たない応答レコードが存在する場合もあります。 しかし、彼らは一般的に調査の問題ではないので、無視することができます。

結合されたログファイルは次のようになります。

![](assets/79f3829e-de9b-ed11-aad1-6045bd006793.png)
<br><br> <br><br> <br><br> <br><br>
<br>分析の例<br><br>例 1. 最も重いアクセス<br><br>
応答のないアクセスを含め、応答時間を降順に並べ替えて、結合されたログファイルを並べ替えます。

![](assets/50d9b9da-de9b-ed11-aad1-6045bd006793.png)
<br><br> <br><br> <br><br> <br><br> <br><br>
<br>例 2. 見つからない応答にアクセス<br><br>
ダミーの応答時間を使用して、対応する応答レコードが欠落しているアクセスを抽出します。

![](assets/7bf0beed-de9b-ed11-aad1-6045bd006793.png)







応答のないアクセスを受信するタイミングがサーバ負荷の増加と相関する場合、これらのアクセスはパフォーマンスの問題を引き起こしている可能性があります。

![](assets/4c86bdff-de9b-ed11-aad1-6045bd006793.png)
<br><br> <br><br> <br><br> <br><br> <br><br> <br><br> <br><br> <br><br> <br><br> <br><br> <br><br>
<br>例 3. 遅いアクセス<br><br>
10 秒以上かかったアクセスを抽出します。

![](assets/028e0518-df9b-ed11-aad1-6045bd006793.png)











ヒット数が多すぎる場合は、grep コマンドの 0-9{5} を 0-9{6} に置き換え、100 秒以上かかったアクセスに絞り込みます。

<br>例 4. 応答時間の時系列データ<br><br>
グラフの作成には、データからタイムスタンプと応答時間のみを抽出すると便利です。

![](assets/e200d731-df9b-ed11-aad1-6045bd006793.png)















即座に応答したアクセスを省略すると、データの効率が向上します。 次の例では、1 秒以上かかったアクセスを抽出します。

![](assets/ec4bd13d-df9b-ed11-aad1-6045bd006793.png)
<br><br> <br><br> <br><br> <br><br> <br><br> <br><br> <br><br>
<br>例 5. 最小、平均（平均）、中央値、最大応答時間<br><br>


![](assets/523f6d50-df9b-ed11-aad1-6045bd006793.png)















上記の例では、統計処理に datamash コマンド (https://www.gnu.org/software/datamash/) を使用しています。 ログに応答のないアクセスが含まれる場合、ダミー値が結果に影響します。

<br>例 6. 1 期間あたりのアクセス数<br><br>
10 分あたりのアクセス数をカウントします。 結果は、大量のトラフィックがパフォーマンスの問題を引き起こしたかどうかを判断するのに役立ちます。

![](assets/16ffe970-df9b-ed11-aad1-6045bd006793.png)







次の例では、データを絞り込んで、POST要求のみにします。 一般的な使用例は、コンテンツオーサリングまたはパブリッシュ層へのレプリケーションが集中しているかどうかを判断することです。

![](assets/9447dd7c-df9b-ed11-aad1-6045bd006793.png)


<br><br> <br><br> <br><br>
<br>例 7. 1 回の期間あたりの応答ステータスの数<br><br>
datamash コマンドを使用して、10 分あたりの各応答ステータスの数のテーブルを作成します。

![](assets/8a91d788-df9b-ed11-aad1-6045bd006793.png)
<br><br> <br><br> <br><br> <br><br>
<br>例 8. 最頻使用 URL<br><br>
10 分ごとに最も頻繁にアクセスされた上位 3 つの URL を印刷します。

![](assets/a04efc9a-df9b-ed11-aad1-6045bd006793.png)


<br><br> <br><br> <br><br> <br><br> <br><br> <br><br> <br><br> <br><br>
<br>例 9. request.log レコードの access.log レコード<br><br>
特定の要求 ID に対応するレコードの access.log を検索します。

![](assets/891a02ad-df9b-ed11-aad1-6045bd006793.png)











同時に同じ URL への複数のアクセスが発生した場合、結果には、1 つのリクエスト ID に対する複数の access.log レコードが表示されます。

<br>まとめ<br><br>
この記事の例が、パフォーマンスの問題の分析に役立つことを願っています。

上記の例は CentOS 7.5 および Ubuntu 22.04LTS でテストされましたが、環境によっては、異なるバージョンやコマンドのバリエーションなど、期待どおりに動作しない場合があります。 環境にインストールされたコマンドに合わせて、適切に調整してください。


